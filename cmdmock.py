#!/usr/bin/env python
# -*- coding: utf-8 -*-
# M Costanzo

""" cmdmock is a simple utility to create a mock version of a command with a specific
argument string (or no arguments). It runs the command, takes the output and hard-codes that
output as a canned response which can then be called and regurigtated. It then tries to set
the file to be executable so a module under test or development can call it transparently
"""

#TODO add hash logic (output hash primary, input hash secondary)
#TODO consider supporting options before the command to change behavior
#TODO optionally enforce exact argument string or return an error
#TODO optionally build up the vocabulary of the mocker by running multiple arguments
# and appending their output
#TODO optionally compress output into a blob in case it is catting a big file for example
#TODO support verbose output
#TODO explicitly add to path for this shell instance?

import sys
import os
import subprocess
import socket
import time
import logging as log
import optparse


def handle_args():
    """Parse out arguments"""
    parser = optparse.OptionParser()
    parser.add_option('-a', '--ado', dest='ado_arg', help='Ado instance to clone metadata from')
    parser.add_option('-f', '--file', dest='xml_file', \
    help='Optionally specify an output destination')
    parser.add_option('-v', '--verbose', action='store_true', dest='verbose', default=False,
                      help='Print informative messages')
    parser.add_option('-d', '--debug', action='store_true', dest='debug', default=False,
                      help='Print all messages including debug')
    (options, args) = parser.parse_args()
    return (options, args)


def get_response(arg_list):
    """ Just runs a subprocess and returns the output """
    proc = subprocess.Popen(arg_list, stdout=subprocess.PIPE)
    proc_response = proc.communicate()
    return proc_response[0]


def write_mock_cmd(cmd, output):
    """ writes a file named cmd with a constant string of the output """

    output_file = cmd + '.py' #TODO drop .py

    shebang = "#!/usr/bin/python\n"
    date = time.strftime("%d/%m/%Y")
    caller = os.getlogin() + '@' + socket.gethostname()

    docstring = '"""This module was generated by mockcmd.py ' + \
    'on ' + date + ' called by ' + caller + '\nwith the following invocation:\n' + \
    str(sys.argv[1:]) + '\n"""\n\n'

    canned_string = "CANNED_OUTPUT  = '''" + output + "'''\n\n"

    print_string = "print CANNED_OUTPUT,"

    try:
        log.debug("Writing content to %s", output_file)
        fp = open(output_file, 'w', 0)
        fp.write(shebang)
        fp.write(docstring)
        fp.write(canned_string)
        fp.write(print_string)
        fp.close()

    except IOError:
        log.exception("write failure")
        sys.exit(1)

    chmod_args = ('chmod a+x ' + output_file).split()
    subprocess.Popen(chmod_args, stdout=subprocess.PIPE)


def main(argv):
    """ Main module. """
    #(options, args) = handle_args()

    log.basicConfig(format="[%(levelname)s]: %(message)s", level=log.DEBUG)

    passed_options = argv[1:]
    log.info("Options passed were: %s", passed_options)
    response = get_response(passed_options)
    log.info("Response was:\n%s", response)
    write_mock_cmd(argv[1], response)


if __name__ == "__main__":
    sys.exit(main(sys.argv))
